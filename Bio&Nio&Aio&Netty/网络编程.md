# BIO同步阻塞IO

## Client

```java
public class Client {
    public static void main(String[] args) throws IOException {
        Socket s = new Socket("127.0.0.1", 8888);
        s.getOutputStream().write("HelloServer".getBytes());
        s.getOutputStream().flush();
        //s.getOutputStream().close();
        System.out.println("write over, waiting for msg back...");
        byte[] bytes = new byte[1024];
        int len = s.getInputStream().read(bytes);
        System.out.println(new String(bytes, 0, len));
        s.close();
    }
}
```

## Server

```java
public class Server {
	public static void main(String[] args) {
		ServerSocket serverSocket = null;
		try {
			// 创建一个服务端
			serverSocket = new ServerSocket();

			serverSocket.bind(new InetSocketAddress("localhost", 8888));

			while (true) {
				// 接受客户端的连接，阻塞方法，直到有客户端连接才往下执行
				Socket accept = serverSocket.accept();
				// 开启一个新的线程来执行对应的逻辑
				new Thread(() -> {
					handle(accept);
				}).start();

			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				serverSocket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	private static void handle(Socket accept) {
		try {
			// 获取输入流
			InputStream inputStream = accept.getInputStream();
			// 创建一个缓冲数组
			byte[] bs = new byte[1024];
			int length = inputStream.read(bs);

			System.out.println(new String(bs, 0, length));
			accept.getOutputStream().write(bs, 0, length);
			accept.getOutputStream().flush();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```

# NIO同步非阻塞IO

>  ### 当单线程中selector负责所有的任务包括轮询事件和事件处理逻辑；也可以加入线程池，将处理读写操作的逻辑扔给线程池做

![](images\NIO.png)

## Client

```java
public class Client {
	public static void main(String[] args) throws IOException {
		SocketChannel socketChannel = SocketChannel.open();
		Selector selector = Selector.open();

		socketChannel.configureBlocking(false);
		socketChannel.connect(new InetSocketAddress("127.0.0.1", 8888));
		//向selector上注册需要监听的时间：连接事件
		socketChannel.register(selector, SelectionKey.OP_CONNECT);

		while (true) {
			selector.select();
			Set<SelectionKey> selectedKeys = selector.selectedKeys();

			for (SelectionKey key : selectedKeys) {
				selectedKeys.remove(key);
				handle(key);
			}
		}
	}

	private static void handle(SelectionKey key) throws IOException {
		if (key.isConnectable()) {
            //获得channel通道
			SocketChannel channel = (SocketChannel) key.channel();
			if (channel.finishConnect()) {
                //设置该通道是非阻塞的
				channel.configureBlocking(false);
                //向钙通道注册事件，同时关心读事件和写事件
				channel.register(key.selector(), SelectionKey.OP_READ | SelectionKey.OP_WRITE);
			}

		} else if (key.isReadable()) {
			SocketChannel socketChannel = (SocketChannel) key.channel();
			ByteBuffer dst = ByteBuffer.allocate(1024);
			int len = socketChannel.read(dst);
			dst.flip();
			System.out.println(new String(dst.array(), 0, len));

			key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
		} else if (key.isWritable()) {
			SocketChannel socketChannel = (SocketChannel) key.channel();
			socketChannel.write(ByteBuffer.wrap("hello server".getBytes()));

			key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);

		}
	}
}

```

## Server

```java
public class Server {
	public static void main(String[] args) throws Exception {
		// 创建一个nio的server服务
		ServerSocketChannel ssc = ServerSocketChannel.open();
		ssc.bind(new InetSocketAddress("localhost", 8888));
		// 设置为非阻塞状态
		ssc.configureBlocking(false);
		System.out.println("server started, listening on :" + ssc.getLocalAddress());
		// 获得一个selector管理对象
		Selector selector = Selector.open();
		// 向服务注册selector管理对象需要监听的事件
		ssc.register(selector, SelectionKey.OP_ACCEPT);
		// 开始循环监听服务端接收到的事件
		while (true) {
			// 这是一个阻塞方法，直到有客户端连接进来的事件发生或是其他读写事件
			selector.select();
			
			Set<SelectionKey> keys = selector.selectedKeys();
			for (SelectionKey key : keys) {
				keys.remove(key);
				handle(key);
			}
		}
	}

	private static void handle(SelectionKey key) throws IOException {
		if (key.isAcceptable()) {
			ServerSocketChannel ssc = (ServerSocketChannel) key.channel();
			// 建立连接通道
			SocketChannel channel = ssc.accept();
			// 设置非阻塞状态
			channel.configureBlocking(false);
			// 在该传输通道上注册读的事件
			channel.register(key.selector(), SelectionKey.OP_READ);
		} else if (key.isReadable()) {
			SocketChannel socketChannel = (SocketChannel) key.channel();
			//分配一个1024长度的ByteBuffer
			ByteBuffer dst = ByteBuffer.allocate(1024);
			int len = socketChannel.read(dst);
			if (len != -1) {
				System.out.println(new String(dst.array(), 0, len));
			}

			socketChannel.register(key.selector(), SelectionKey.OP_WRITE);

		} else if (key.isWritable()) {
			SocketChannel socketChannel = (SocketChannel) key.channel();

			ByteBuffer buffer = ByteBuffer.wrap("hello client".getBytes());

			socketChannel.write(buffer);
			socketChannel.register(key.selector(), SelectionKey.OP_READ);
//			socketChannel.close();
		}
	}
}
```

## 源码

### Channel

```java
/**
 *通道表示与诸如硬件设备，文件，网络套接字或程序组件之类的实体的开放连接，该实体能够执行一个或多个不同的I / O操作（例如，读取或写入）。
 * <p> A channel represents an open connection to an entity such as a hardware
 * device, a file, a network socket, or a program component that is capable of
 * performing one or more distinct I/O operations, for example reading or
 * writing.
 *
 通常，通道的目的是确保多线程访问的安全，如接口规范以及扩展和实现此接口的类中所述
  * <p> Channels are, in general, intended to be safe for multithreaded access
 * as described in the specifications of the interfaces and classes that extend
 * and implement this interface.
 */
public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;
}
```

### ReadableByteChannel

```java
/**
 * A channel that can read bytes.
 */
public interface ReadableByteChannel extends Channel {
  public int read(ByteBuffer dst) throws IOException;   
}
```

### ByteChannel

```java
/**
可以读取和写入字节的通道
 * A channel that can read and write bytes.  This interface simply unifies
 * {@link ReadableByteChannel} and {@link WritableByteChannel}; it does not
 * specify any new operations.
 */
public interface ByteChannel
    extends ReadableByteChannel, WritableByteChannel
{}
```

### SeekableByteChannel

```java
/**
 一个字节通道，它保持当前位置并允许更改位置。
 * A byte channel that maintains a current <i>position</i> and allows the
 * position to be changed.
 
 通道还提供对通道所连接实体的当前大小的访问
 *The channel also provides access to the current <i>size</i> of the entity to which the channel is connected
 */
public interface SeekableByteChannel
    extends ByteChannel
{
}  
```

### FileChannel

```java
/**
 * A channel for reading, writing, mapping, and manipulating a file.
 */
 public abstract class FileChannel
    extends AbstractInterruptibleChannel
    implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel
 {}
```

### Buffer

![](images\Buffer三点.png)

```java
/**
特定原始类型数据的容器。
 * A container for data of a specific primitive type.
 
 缓冲区是特定原始类型的元素的线性有限序列。 除了内容之外，缓冲区的基本属性是其容量，临界点和位置
  * <p> A buffer is a linear, finite sequence of elements of a specific
 * primitive type.  Aside from its content, the essential properties of a
 * buffer are its capacity, limit, and position: </p>
 *
 缓冲区的capacity是其包含的元素数。 缓冲区的容量永远不会为负，永远不会改变
  *   <p> A buffer's <i>capacity</i> is the number of elements it contains.  The
 *   capacity of a buffer is never negative and never changes.  </p>
 *
 缓冲区的限制是不应读取或写入的第一个元素的索引。 缓冲区的限制永远不会为负，并且永远不会大于缓冲区的容量
  *   <p> A buffer's <i>limit</i> is the index of the first element that should
 *   not be read or written.  A buffer's limit is never negative and is never
 *   greater than its capacity.  </p>
 
 缓冲区的位置是下一个要读取或写入的元素的索引。 缓冲区的位置永远不会为负，并且永远不会大于其限制 
  *   <p> A buffer's <i>position</i> is the index of the next element to be
 *   read or written.  A buffer's position is never negative and is never
 *   greater than its limit.  </p>
 */

public abstract class Buffer {
    
        // Invariants: mark <= position <= limit <= capacity
    private int mark = -1;
    private int position = 0;
    private int limit;
    private int capacity;
    
    Buffer(int mark, int pos, int lim, int cap) {       // package-private
        if (cap < 0)
            throw new IllegalArgumentException("Negative capacity: " + cap);
        this.capacity = cap;
        limit(lim);
        position(pos);
        if (mark >= 0) {
            if (mark > pos)
                throw new IllegalArgumentException("mark > position: ("
                                                   + mark + " > " + pos + ")");
            this.mark = mark;
        }
    }
}
```

### ByteBuffer

![](images\DirectBuffer-nonDirectBuffer.png)

Direct Buffer:

- 所分配的内存不在 JVM 堆上, 不受 GC 的管理.(但是 Direct Buffer 的 Java 对象是由 GC 管理的, 因此当发生 GC, 对象被回收时, Direct Buffer 也会被释放)
- 因为 Direct Buffer 不在 JVM 堆上分配, 因此 Direct Buffer 对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存, 但是 JVM 不好统计到非 JVM 管理的内存.)
- 申请和释放 Direct Buffer 的开销比较大. 因此正确的使用 Direct Buffer 的方式是在初始化时申请一个 Buffer, 然后不断复用此 buffer, 在程序结束后才释放此 buffer.
- 使用 Direct Buffer 时, 当进行一些底层的系统 IO 操作时, 效率会比较高, 因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中.

Non-Direct Buffer:

- 直接在 JVM 堆上进行内存的分配, 本质上是 byte[] 数组的封装.
- 因为 Non-Direct Buffer 在 JVM 堆中, 因此当进行操作系统底层 IO 操作中时, 会将此 buffer 的内存复制到中间临时缓冲区中. 因此 Non-Direct Buffer 的效率就较低.

```java
/* <a name="direct"></a>
 * <h2> Direct <i>vs.</i> non-direct buffers </h2>
 */
public abstract class ByteBuffer extends Buffer implements Comparable<ByteBuffer>
{
    
    final byte[] hb;                  // Non-null only for heap buffers
    final int offset;
    boolean isReadOnly;                 // Valid only for heap buffers
    
    ByteBuffer(int mark, int pos, int lim, int cap,   // package-private
                 byte[] hb, int offset)
    {
        //初始化 mark  position  limit  capacity
        super(mark, pos, lim, cap);
        this.hb = hb;
        this.offset = offset;//偏移量
    }
    
    public static ByteBuffer allocate(int capacity) {
        if (capacity < 0)
            throw new IllegalArgumentException();
        return new HeapByteBuffer(capacity, capacity);
    }
    
     public static ByteBuffer allocateDirect(int capacity) {
        return new DirectByteBuffer(capacity);
    }
}
```

#### MappedByteBuffer

> 可以直接在堆外内存中修改文件，操作系统不需要拷贝一次

#### HeapByteBuffer

```java
class HeapByteBuffer extends ByteBuffer
{
    HeapByteBuffer(int cap, int lim) {            // package-private
        //默认使用的是字节数组存储
        super(-1, 0, lim, cap, new byte[cap], 0);
        /*
        hb = new byte[cap];
        offset = 0;
        */
    }
    //如果插入的是字节，就会取到下一个位置进行插入
    //如果插入的是char,int,long...,就会将内容进行右移操作取到每一个字节，然后插入
        public ByteBuffer put(byte x) {
        hb[ix(nextPutIndex())] = x;
        return this;
    }
}
```

#### DirectByteBuffer

> #### 通过Unsafe这个类进行内存的分配，对buffer操作也是通过Unsafe这个类
>
> #### Unsafe类提供了手动管理内存的能力

```java
class DirectByteBuffer
    extends MappedByteBuffer
    implements DirectBuffer
{
    // Primary constructor
    //
    DirectByteBuffer(int cap) {                   // package-private

        super(-1, 0, cap, cap);
        boolean pa = VM.isDirectMemoryPageAligned();
        int ps = Bits.pageSize();
        long size = Math.max(1L, (long)cap + (pa ? ps : 0));
        Bits.reserveMemory(size, cap);

        long base = 0;
        try {
            
            base = unsafe.allocateMemory(size);
        } catch (OutOfMemoryError x) {
            Bits.unreserveMemory(size, cap);
            throw x;
        }
        unsafe.setMemory(base, size, (byte) 0);
        if (pa && (base % ps != 0)) {
            // Round up to page boundary
            address = base + ps - (base & (ps - 1));
        } else {
            address = base;
        }
        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
        att = null;
    }
}
```

### FileChannelImpl*

```###java
public class FileChannelImpl extends FileChannel {
    
    public int read(ByteBuffer var1) throws IOException {
        this.ensureOpen();
        if (!this.readable) {
            throw new NonReadableChannelException();
        } else {
            Object var2 = this.positionLock;
            synchronized(this.positionLock) {
                int var3 = 0;
                int var4 = -1;

                byte var5;
                try {
                    this.begin();
                    var4 = this.threads.add();
                    if (this.isOpen()) {
                        do {
                            var3 = IOUtil.read(this.fd, var1, -1L, this.nd);
                        } while(var3 == -3 && this.isOpen());

                        int var12 = IOStatus.normalize(var3);
                        return var12;
                    }
                    var5 = 0;
                } finally {
                    this.threads.remove(var4);
                    this.end(var3 > 0);

                    assert IOStatus.check(var3);
                }
                return var5;
            }
        }
    }
}

public class IOUtil {
    
    static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {
        if (var1.isReadOnly()) {
            throw new IllegalArgumentException("Read-only buffer");
           //判断是否属于直接缓冲区DirectBuffer
        } else if (var1 instanceof DirectBuffer) {
            //直接将内容读取到ByteBuffer中
            return readIntoNativeBuffer(var0, var1, var2, var4);
        } else {
            //如果不属于直接缓冲区DirectBuffer，先获取一个和var1大小一样的DirectBuffer
            ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());

            int var7;
            try {
                //将内容读取到DirectBuffer var5中
                int var6 = readIntoNativeBuffer(var0, var5, var2, var4);
                var5.flip();
                //然后再讲var5中的内容插入到var1中
                if (var6 > 0) {
                    var1.put(var5);
                }

                var7 = var6;
            } finally {
                Util.offerFirstTemporaryDirectBuffer(var5);
            }

            return var7;
        }
    }
}
```

### SelectableChannel

```java
/**
通过selector进行多路复用的通道
 * A channel that can be multiplexed via a {@link Selector}.
 *
 为了用上selector，首先该类的实例必须被注册通过register(Selector,int,Object)方法
 * <p> In order to be used with a selector, an instance of this class must
 * first be <i>registered</i> via the {@link #register(Selector,int,Object)
 * register} method.  This method returns a new {@link SelectionKey} object
 * that represents the channel's registration with the selector.
 *
 一旦注册了selector，通道保持注册直到它被解绑。
 * <p> Once registered with a selector, a channel remains registered until it
 * is <i>deregistered</i>.  
  这个涉及到selector取消分配给通道的任何资源
 This involves deallocating whatever resources were
 * allocated to the channel by the selector.
 *
 通道不能直接被取消解绑；相反，key代表了注册被取消了。
 * <p> A channel cannot be deregistered directly; instead, the key representing
 * its registration must be <i>cancelled</i>.  
 取消key请求，channel的在selector的下一个选择操作期间被解绑
 Cancelling a key requests that  the channel be deregistered during the selector's next selection operation.
 * A key may be cancelled explicitly by invoking its {@link
 * SelectionKey#cancel() cancel} method.  All of a channel's keys are cancelled
 * implicitly when the channel is closed, whether by invoking its {@link
 * Channel#close close} method or by interrupting a thread blocked in an I/O
 * operation upon the channel.
 */
public abstract class SelectableChannel
    extends AbstractInterruptibleChannel
    implements Channel
{
}
```



### **Selector

```java
/**
一个多路复用器对象
 * A multiplexor of {@link SelectableChannel} objects.
 *
 一个selector可以通过调用该类的open方法创建得到
 * <p> A selector may be created by invoking the {@link #open open} method of this class,
 将使用系统默认的SelectorProvider去创建selector
  which will use the system's default {@link
 * java.nio.channels.spi.SelectorProvider selector provider} to
 * create a new selector.  
 
 一个selector也可以通过一个自定义selector调用SelectorProvider的openSelector创建
 A selector may also be created by invoking the
 * {@link java.nio.channels.spi.SelectorProvider#openSelector openSelector}
 * method of a custom selector provider. 
 
 一个selector保持开启直到调用了close方法
 A selector remains open until it is
 * closed via its {@link #close close} method.
 
  * <p> A selectable channel's registration with a selector is represented by a
 * {@link SelectionKey} object.  A selector maintains three sets of selection
 * keys:
 *
 
  * <ul>
 *
 key集合包含的keys代表了当前selector被注册的channel
 *   <li><p> The <i>key set</i> contains the keys representing the current
 *   channel registrations of this selector.  This set is returned by the
 *   {@link #keys() keys} method. </p></li>
 *
 selected-key集合是是键集合，在选择操作期间每一个key的channel被检测到准备好至少一个key的兴趣集中的一个操作
 *   <li><p> The <i>selected-key set</i> is the set of keys such that each
 *   key's channel was detected to be ready for at least one of the operations
 *   identified in the key's interest set during a prior selection operation.
 *   This set is returned by the {@link #selectedKeys() selectedKeys} method.
 
 selected-key set永远是key set的子集
 *   The selected-key set is always a subset of the key set. </p></li>
 *
 cancelled-key集合是一个键集合，已经被取消但是其通道还没有被注销
 *   <li><p> The <i>cancelled-key</i> set is the set of keys that have been
 *   cancelled but whose channels have not yet been deregistered.  
 此集合是不可被直接访问的
 This set is not directly accessible.  The cancelled-key set is always a subset of the
 *   key set. </p></li>
 *

 一个key通过register(Selector,int)方法注册到Key set中起到额外的作用
 * <p> A key is added to a selector's key set as a side effect of registering a
 * channel via the channel's {@link SelectableChannel#register(Selector,int)
 * register} method. 
 
 取消keys，在selection操作期间会被从key中移除。key set自身是不会直接修改的
 Cancelled keys are removed from the key set during
 * selection operations.  The key set itself is not directly modifiable.
 *
 当一个key被取消后会被添加到 cancelled-key set中，无论是通过关闭通道或者是执行cancel方法。
 * <p> A key is added to its selector's cancelled-key set when it is cancelled,
 * whether by closing its channel or by invoking its {@link SelectionKey#cancel
 * cancel} method.  
 
 取消一个key，在下一个selection操作期间，将会导致channel被注销
 Cancelling a key will cause its channel to be deregistered
 * during the next selection operation, at which time the key will removed from
 * all of the selector's key sets.
 *
 * <a name="sks"></a><p> Keys are added to the selected-key set by selection
 * operations.  A key may be removed directly from the selected-key set by
 * invoking the set's {@link java.util.Set#remove(java.lang.Object) remove}
 * method or by invoking the {@link java.util.Iterator#remove() remove} method
 * of an {@link java.util.Iterator iterator} obtained from the
 * set.  Keys are never removed from the selected-key set in any other way;
 * they are not, in particular, removed as a side effect of selection
 * operations.  Keys may not be added directly to the selected-key set. </p>
 *
  cancelled-key set中的每一个key都从所属的key set中移除，并且它的通道也被注销，这步将cancelled-key设置成空
  *   <li><p> Each key in the cancelled-key set is removed from each key set of
 *   which it is a member, and its channel is deregistered.  This step leaves
 *   the cancelled-key set empty. </p></li>
 

 * <h2>Concurrency</h2>
 *
 Selectors本身提供安全的并发访问；但是key sets不是的
 * <p> Selectors are themselves safe for use by multiple concurrent threads;
 * their key sets, however, are not.
 *
 selection操作在selector，key set和selected-key set上是同步的。它们还会在上述步骤（1）和（3）期间同步cancelled-key set
 * <p> The selection operations synchronize on the selector itself, on the key
 * set, and on the selected-key set, in that order.  They also synchronize on
 * the cancelled-key set during steps (1) and (3) above.
 *
 在selection操作过程中对兴趣集的更改，对该操作是无效的；更改效果将在下一次选择操作中见效
 * <p> Changes made to the interest sets of a selector's keys while a
 * selection operation is in progress have no effect upon that operation; they
 * will be seen by the next selection operation.
 *
 keys在任何时候都有可能被取消，channels在任何时候都有可能被关闭。
 * <p> Keys may be cancelled and channels may be closed at any time.  
 因此，一个或多个选择器的键集中存在键并不意味着该键有效或其通道已打开。
 Hence the presence of a key in one or more of a selector's key sets does not imply
 * that the key is valid or that its channel is open.  Application code should
 * be careful to synchronize and check these conditions as necessary if there
 * is any possibility that another thread will cancel a key or close a channel.
 *
 一个线程在调用select方法时阻塞，可能会被其他线程打断
 * <p> A thread blocked in one of the {@link #select()} or {@link
 * #select(long)} methods may be interrupted by some other thread in one of
 * three ways:
 *
 * <ul>
 *
 *   <li><p> By invoking the selector's {@link #wakeup wakeup} method,
 *   </p></li>
 *
 *   <li><p> By invoking the selector's {@link #close close} method, or
 *   </p></li>
 *通过执行阻塞线程的interrupt方法，在这种情况下将其设置成中断状态并且selector的wakeup将执行
 *   <li><p> By invoking the blocked thread's {@link
 *   java.lang.Thread#interrupt() interrupt} method, in which case its
 *   interrupt status will be set and the selector's {@link #wakeup wakeup}
 *   method will be invoked. </p></li>
 
 close方法以与选择操作相同的顺序在选择器和所有三个键集上同步
  * <p> The {@link #close close} method synchronizes on the selector and all
 * three key sets in the same order as in a selection operation.
 
 通常selector的key和selected-key sets不能安全的被多个并发线程使用
  * <p> A selector's key and selected-key sets are not, in general, safe for use
 * by multiple concurrent threads.  
 
 如果这样的线程可能直接修改这些集合之一，则应通过在集合本身上进行同步来控制访问
 If such a thread might modify one of these sets directly then access should be controlled by synchronizing on the set itself.  
 
 The iterators returned by these sets' {@link java.util.Set#iterator() iterator} methods are <i>fail-fast:</i> If the set
 * is modified after the iterator is created, in any way except by invoking the
 * iterator's own {@link java.util.Iterator#remove() remove} method, then a
 * {@link java.util.ConcurrentModificationException} will be thrown. </p>
 */

public abstract class Selector implements Closeable {
    
}

public abstract class SelectorProvider {
    
    public static Selector open() throws IOException {
        return SelectorProvider.provider().openSelector();
    }
}

public class DefaultSelectorProvider {
    private DefaultSelectorProvider() {
    }

    public static SelectorProvider create() {
        //这个返回的看操作系统的版本
        return new WindowsSelectorProvider();
    }
}
```

# AIO异步非阻塞IO

## Server

```java
public class Server {

	public static void main(String[] args) {
		try {
			//获得一个异步的ServerSocketChannel
			AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open()
					.bind(new InetSocketAddress("localhost", 8888));
			//这是异步操作，主线程执行完这句，就会直接往下走，创建一个CompletionHandler让操作系统调用
			serverSocketChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {

				@Override
				public void completed(AsynchronousSocketChannel client, Object attachment) {
					//用于接收下一个客户端的连接，不写就会接收不到下一个客户端的连接
					serverSocketChannel.accept(null, this);
					ByteBuffer buffer = ByteBuffer.allocate(1024);

					client.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {

						@Override
						public void completed(Integer result, ByteBuffer attachment) {
							attachment.flip();
							System.out.println(new String(attachment.array(), 0, result));
							client.write(ByteBuffer.wrap("HelloClient".getBytes()));
						}

						@Override
						public void failed(Throwable exc, ByteBuffer attachment) {
							exc.printStackTrace();
						}
					});
					
				}

				@Override
				public void failed(Throwable exc, Object attachment) {
					exc.printStackTrace();
				}
			});
		} catch (IOException e) {
			e.printStackTrace();
		}

		while (true) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}

```

# Netty

> ### 自定义编解码器，在一端两者都添加，系统会自动判断执行编码器还是解码器



## Server

```java
public class Server {
	public static void main(String[] args) {
        //线程池
		NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);
		NioEventLoopGroup workerGroup = new NioEventLoopGroup(3);
		//服务
		ServerBootstrap serverBootstrap = new ServerBootstrap();
		
		try {
            //加入的两个线程池，第一个负责客户端的连接，第二个负责与客户端的交互
			serverBootstrap.group(bossGroup, workerGroup)
                //通道类型NioServerSocketChannel
				.channel(NioServerSocketChannel.class)
                //子线程需要处理的逻辑，ServerChannel初始化
				.childHandler(new ServerChannelInitializer() )
                .bind(8888)
					.sync()//这里阻塞住等待服务启动成功
					.channel().closeFuture().sync();//阻塞等待关闭服务器
		} catch (InterruptedException e) {
			e.printStackTrace();
		}finally {
            //关闭资源，线程池
			bossGroup.shutdownGracefully();
			workerGroup.shutdownGracefully();
		}
	}
}
class ServerChannelInitializer extends ChannelInitializer<SocketChannel>{

	@Override
	protected void initChannel(SocketChannel ch) throws Exception {
		//获取管道
		ChannelPipeline pipeline = ch.pipeline();
		//给管道添加处理逻辑，自定义的消息解码器
		pipeline.addLast(new MessageDecoder());
        //添加服务端channel处理逻辑
		pipeline.addLast(new ServerChannelInboundHandlerAdapter());
	}
}
class ServerChannelInboundHandlerAdapter extends ChannelInboundHandlerAdapter{

	@Override
	public void channelActive(ChannelHandlerContext ctx) throws Exception {
		System.out.println("通道初始化完成");
		ctx.writeAndFlush(Unpooled.copiedBuffer("hello client".getBytes()));
	}

	@Override
	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
		try {
            //判断是否是自定义的消息类型
			if(msg instanceof MyMessage){
				MyMessage message=(MyMessage) msg;
				System.out.println(message);
			}else{
				ByteBuf words = (ByteBuf) msg;
				byte[] by = new byte[words.readableBytes()];
				//将信息存入字节数组中
				words.getBytes(words.readerIndex(), by);
				System.out.println(ctx.channel().id() + ": " + new String(by));
			}
		} finally {
			if(msg!=null){
                //释放掉该条消息的资源
				ReferenceCountUtil.release(msg);
			}
		}
	}
}
```

## Client

```java
public class Client {
	ChannelHandlerContext ctx=null;
	
	public static void main(String[] args) {
		Client client = new Client();
		client.connect();
		
	}
	public void connect(){
		NioEventLoopGroup group = new NioEventLoopGroup();
		Bootstrap bootstrap = new Bootstrap();
		
		try {
			ChannelFuture future = 
                //客户端不需要像服务端一样需要就收连接，只需要一个线程池
                bootstrap.group(group).channel(NioSocketChannel.class)
                //ClientChannel通道初始化
				.handler(new ClientChannelInitializer(this))
				.connect("localhost",8888);//连接的具体的ip地址和端口
				//添加事件监听机制
				future.addListener(new ChannelFutureListener() {
					
					@Override
					public void operationComplete(ChannelFuture future) throws Exception {
						if(future.isSuccess()){
							System.out.println("连接成功");
						}else{
							System.out.println("连接失败");
						}
					}
				});
			
				future.sync();//阻塞等待连接成功
				
				new Thread(()->{
					Scanner scanner = new Scanner(System.in);
					boolean flag=true;
					while(true){
						String words = scanner.nextLine();
                        
                 //Unpooled.copiedBuffer(words.getBytes())获得指定字节数组的ByteBuf
                        //向服务端写出指定字节数组
					this.ctx.writeAndFlush(Unpooled.copiedBuffer(words.getBytes()));
						if("exit".trim().equals(words)){
							flag=true;
						}
					}
				}).start();
				
				future.channel().closeFuture().sync();//阻塞等待调用关闭
		} catch (InterruptedException e) {
			e.printStackTrace();
		}finally {
			group.shutdownGracefully();
		}
	}
}
class ClientChannelInitializer extends ChannelInitializer<SocketChannel>{
	private Client client;
	
	public ClientChannelInitializer(Client client) {
		this.client=client;
	}
	
	@Override
	protected void initChannel(SocketChannel ch) throws Exception {
		ChannelPipeline pipeline = ch.pipeline();
        //添加自定义消息编码器，
		pipeline.addLast(new MessageEncoder());
        //ClentChannel逻辑处理
		pipeline.addLast(new ClientChannelInboundHandlerAdapter(this.client));
	}
	
}
class ClientChannelInboundHandlerAdapter extends ChannelInboundHandlerAdapter{
	private Client client;
	
	public ClientChannelInboundHandlerAdapter(Client client) {
		this.client=client;
	}
	
    //通道初始完毕后调用该函数
	@Override
	public void channelActive(ChannelHandlerContext ctx) throws Exception {
		client.ctx=ctx;
//		ctx.writeAndFlush(Unpooled.copiedBuffer("hello server".getBytes()));
		ctx.writeAndFlush(new MyMessage(5, 6));
	}

	@Override
	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
		
		try {
			ByteBuf buf = (ByteBuf) msg;
			byte[] by = new byte[buf.readableBytes()];
			buf.getBytes(buf.readerIndex(), buf);
			System.out.println(ctx.channel().id() + ": " + new String(by));
		} finally {
			if(msg!=null){
				ReferenceCountUtil.release(msg);
			}
		}
	}
}
```

## 自定义消息，消息编解码器

消息

```java
public class MyMessage {
	private int x;
	private int y;
	
	public MyMessage(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
}
```

编码器

继承MessageToByteEncoder指定自定义消息类型

```java
public class MessageEncoder extends MessageToByteEncoder<MyMessage> {

	@Override
	protected void encode(ChannelHandlerContext ctx, MyMessage msg, ByteBuf out) throws Exception {
		out.writeInt(msg.getX());
		out.writeInt(msg.getY());
	}
}
```

解码器

继承ByteToMessageDecoder

```java
public class MessageDecoder extends ByteToMessageDecoder {

	@Override
	protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        //这里判断消息是否完整，如果不完整则返回，长度计算是总字节长度
		if(in.readableBytes()<8){
			return;
		}
		int x=in.readInt();
		int y=in.readInt();
		//加入指定类型的消息
		out.add(new MyMessage(x, y));
	}
}
```



# Netty源码

> ### 内部封装的是nio，但是实现了可以完全异步操作，实现的是事件循环组，通过next获取到下一个事件执行器，将需要异步操作的任务交给它



![](images\netty结构类图.png)

## EventExecutorGroup事件执行器组

```java
/**
EventExecutorGroup主要提供EventExecutor通过next方法获得,除此之外还主要处理生命周期并且允许关闭
 * The {@link EventExecutorGroup} is responsible for providing the {@link EventExecutor}'s to use
 * via its {@link #next()} method. Besides this, it is also responsible for handling their
 * life-cycle and allows shutting them down in a global fashion.
 *
 */
public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<EventExecutor> {
```

## EventExecutor事件执行器

```java
/**
EventExecutor是一个特殊的EventExecutorGroup，带有一些方便的方法查看是否一个Thread在事件循环中执行
 * The {@link EventExecutor} is a special {@link EventExecutorGroup} which comes
 * with some handy methods to see if a {@link Thread} is executed in a event loop.
 * Besides this, it also extends the {@link EventExecutorGroup} to allow for a generic
 * way to access methods.
 *
 */
public interface EventExecutor extends EventExecutorGroup {
```

## EventLoopGroup事件循环组

```java
/**
特殊的EventExecutorGroup，它可以注册Channel，这些事件将在事件循环中进行处理以供以后选择。
 * Special {@link EventExecutorGroup} which allows registering {@link Channel}s that get processed for later selection during the event loop.
 *
 */
public interface EventLoopGroup extends EventExecutorGroup {
```

## AbstractExecutorService

```java
/**
提供ExecutorService执行方法的默认实现
 * Provides default implementations of {@link ExecutorService}
 * execution methods. This class implements the {@code submit},
 * {@code invokeAny} and {@code invokeAll} methods using a
 * {@link RunnableFuture} returned by {@code newTaskFor}, which defaults
 * to the {@link FutureTask} class provided in this package.  For example,
 * the implementation of {@code submit(Runnable)} creates an
 * associated {@code RunnableFuture} that is executed and
 * returned. Subclasses may override the {@code newTaskFor} methods
 * to return {@code RunnableFuture} implementations other than
 * {@code FutureTask}.
 */
public abstract class AbstractExecutorService implements ExecutorService {
    
}
```

## AbstractEventExecutor

```java
/**
  EventExecutor实现的抽象基类
 * Abstract base class for {@link EventExecutor} implementations.
 */
public abstract class AbstractEventExecutor extends AbstractExecutorService implements EventExecutor {
    @Override
    public EventExecutor next() {
        return this;
    }

    @Override
    public boolean inEventLoop() {
        return inEventLoop(Thread.currentThread());
    }
}
```

## AbstractScheduledEventExecutor

```java
/**
想要有scheduling功能的{@link EventExecutor}的抽象基类。
 * Abstract base class for {@link EventExecutor}s that want to support scheduling.
 */
public abstract class AbstractScheduledEventExecutor extends AbstractEventExecutor {
    
    PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;
}
```

## SingleThreadEventExecutor

```java
/**
OrderedEventExecutor的抽象基类，它在单个线程中执行所有已提交的任务
 * Abstract base class for {@link OrderedEventExecutor}'s that execute all its submitted tasks in a single thread.
 *
 */
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor {
        static final int DEFAULT_MAX_PENDING_EXECUTOR_TASKS = Math.max(16,
            SystemPropertyUtil.getInt("io.netty.eventexecutor.maxPendingTasks", Integer.MAX_VALUE));
    //队列有序，先进先出
    private final Queue<Runnable> taskQueue;
}
```

## DefaultEventExecutor

```java
/**
默认的SingleThreadEventExecutor实现仅以串行方式执行所有提交的任务。
 * Default {@link SingleThreadEventExecutor} implementation which just execute all submitted task in a serial fashion.
 */
public final class DefaultEventExecutor extends SingleThreadEventExecutor {
```

## MultithreadEventExecutorGroup

```java
/**
EventExecutorGroup实现的抽象基类，可同时处理多个线程的任务。
 * Abstract base class for {@link EventExecutorGroup} implementations that handles their tasks with multiple threads at the same time.
 */
public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup {

    private final EventExecutor[] children;
    private final Set<EventExecutor> readonlyChildren;
    private final AtomicInteger terminatedChildren = new AtomicInteger();
    private final Promise<?> terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);
    private final EventExecutorChooserFactory.EventExecutorChooser chooser;
 
        @Override
    public EventExecutor next() {
        return chooser.next();
    }
}
```

## MultithreadEventLoopGroup

```java
/**
EventLoopGroup实现的抽象基类，可同时处理多个线程的任务。
 * Abstract base class for {@link EventLoopGroup} implementations that handles their tasks with multiple threads at
 * the same time.
 */
public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup {
```

## NioEventLoopGroup

```java
/**
 * {@link MultithreadEventLoopGroup} implementations which is used for NIO {@link Selector} based {@link Channel}s.
 */
public class NioEventLoopGroup extends MultithreadEventLoopGroup {
    @Override
    protected EventLoop newChild(Executor executor, Object... args) throws Exception {
        EventLoopTaskQueueFactory queueFactory = args.length == 4 ? (EventLoopTaskQueueFactory) args[3] : null;
        return new NioEventLoop(this, executor, (SelectorProvider) args[0],
            ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2], queueFactory);
    }
}
```

## NioEventLoop

```java
/**
 * {@link SingleThreadEventLoop} implementation which register the {@link Channel}'s to a
 * {@link Selector} and so does the multi-plexing of these in the event loop.
 *
 */
public final class NioEventLoop extends SingleThreadEventLoop {
```

## Unpooled--netty中用于内存管理

```java
/**
创建一个新的ByteBuf通过分配一个新的空间或者是包装或拷贝现有byte数组，byte buffers，字符串。
 * Creates a new {@link ByteBuf} by allocating new space or by wrapping
 * or copying existing byte arrays, byte buffers and a string.
 
* {@link ByteBuf} heapBuffer    = buffer(128);
 * {@link ByteBuf} directBuffer  = directBuffer(256);
 * {@link ByteBuf} wrappedBuffer = wrappedBuffer(new byte[128], new byte[256]);
 * {@link ByteBuf} copiedBuffer  = copiedBuffer({@link ByteBuffer}.allocate(128));
 * </pre>
 *
 分配一个新的buffer
 * <h3>Allocating a new buffer</h3>
 *
  提供三种buffer类型
 * Three buffer types are provided out of the box.
 *
 * <ul>堆buffer,直接内存buffer，包裹buffer
 * <li>{@link #buffer(int)} allocates a new fixed-capacity heap buffer.</li>
 * <li>{@link #directBuffer(int)} allocates a new fixed-capacity direct buffer.</li>
  * <li>{@link #wrappedBuffer(byte[]... arrays)} .</li>
 * </ul>
 *
 * <h3>Creating a wrapped buffer</h3>
 包装缓冲区是一个或多个byte数组或byte buffers的视图。
  * Wrapped buffer is a buffer which is a view of one or more existing
 * byte arrays and byte buffers.  
 
 原始数组或buffer的内容任何改变，在包装buffer中都是可见的。
 Any changes in the content of the original array or buffer will be visible in the wrapped buffer. 
 
 多种wrapper methods被提供并且他们的名字都是wrappedBuffer
 Various wrapper methods are provided and their name is all {@code wrappedBuffer()}.
 
 如果要创建一个由多个数组组成的缓冲区以减少内存复制数量，则可能需要仔细研究一下接受varargs的方法。
 * You might want to take a look at the methods that accept varargs closely if
 * you want to create a buffer which is composed of more than one array to
 * reduce the number of memory copy.
 *
 * <h3>Creating a copied buffer</h3>
 *
 拷贝到buffer是一个或多个byte数组，byte buffers，string的深层拷贝。
 * Copied buffer is a deep copy of one or more existing byte arrays, byte
 * buffers or a string. 
 
 与包装的缓冲区不同，原始数据和复制的缓冲区之间没有共享数据
 Unlike a wrapped buffer, there's no shared data between the original data and the copied buffer. 
 Various copy methods are provided and their name is all {@code copiedBuffer()}.  It is also convenient to use this operation to merge multiple buffers into one buffer.
 */
public final class Unpooled {

    /**
     * Creates a new big-endian Java heap buffer with the specified {@code capacity}, which
     * expands its capacity boundlessly on demand.  The new buffer's {@code readerIndex} and
     * {@code writerIndex} are {@code 0}.
     */
    public static ByteBuf buffer(int initialCapacity) {
        //分配堆内存
        return ALLOC.heapBuffer(initialCapacity);
    }
}
```

```java
//AbstractByteBufAllocator类
@Override
public ByteBuf heapBuffer(int initialCapacity) {
    return heapBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);
}
@Override
    public ByteBuf heapBuffer(int initialCapacity, int maxCapacity) {
        if (initialCapacity == 0 && maxCapacity == 0) {
            return emptyBuf;
        }
        validate(initialCapacity, maxCapacity);
        return newHeapBuffer(initialCapacity, maxCapacity);
    }

//UnpooledByteBufAllocator类
 @Override
    protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) {
        return PlatformDependent.hasUnsafe() ?
                new InstrumentedUnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :
                new InstrumentedUnpooledHeapByteBuf(this, initialCapacity, maxCapacity);
    }


//UnpooledHeapByteBuf类
public UnpooledHeapByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {
        super(maxCapacity);

        if (initialCapacity > maxCapacity) {
            throw new IllegalArgumentException(String.format(
                    "initialCapacity(%d) > maxCapacity(%d)", initialCapacity, maxCapacity));
        }

        this.alloc = checkNotNull(alloc, "alloc");
        setArray(allocateArray(initialCapacity));
        setIndex(0, 0);
    }

protected byte[] allocateArray(int initialCapacity) {
        return new byte[initialCapacity];
}

@Override
public ByteBuf setIndex(int readerIndex, int writerIndex) {
    if (checkBounds) {
        checkIndexBounds(readerIndex, writerIndex, capacity());
    }
    setIndex0(readerIndex, writerIndex);
    return this;
}

```

## UnpooledHeapByteBuf--netty底层存储byte[]

```java
public class UnpooledHeapByteBuf extends AbstractReferenceCountedByteBuf {
    protected byte[] allocateArray(int initialCapacity) {
        return new byte[initialCapacity];
    }
}
```

## ServerBootstrap/Bootstrap

```java
/**
 * {@link Bootstrap} sub-class which allows easy bootstrap of {@link ServerChannel}
 *
 */
/**
 * A {@link Bootstrap} that makes it easy to bootstrap a {@link Channel} to use
 * for clients.
 */
```

##  Channel

```java
/**
与网络套接字或能够进行I / O操作（例如读取，写入，连接和绑定）的组件的联系。
 * A nexus to a network socket or a component which is capable of I/O
 * operations such as read, write, connect, and bind.
 * <p>
 * A channel provides a user:
 * <ul>
 * <li>the current state of the channel (e.g. is it open? is it connected?),</li>
 * <li>the {@linkplain ChannelConfig configuration parameters} of the channel (e.g. receive buffer size),</li>
 * <li>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and</li>
 * <li>the {@link ChannelPipeline} which handles all I/O events and requests
 *     associated with the channel.</li>
 * </ul>
 
  所有的i/o操作都是异步的
 * <h3>All I/O operations are asynchronous.</h3>
 
 Netty中的所有I / O操作都是异步的。 这意味着任何I / O调用都将立即返回，而不能保证所请求的I / O操作已在调用结束时完成。 相反，您将返回一个 ChannelFuture实例，该实例将在请求的I / O操作成功，失败或取消时通知您。
 * All I/O operations in Netty are asynchronous.  It means any I/O calls will
 * return immediately with no guarantee that the requested I/O operation has
 * been completed at the end of the call.  Instead, you will be returned with
 * a {@link ChannelFuture} instance which will notify you when the requested I/O
 * operation has succeeded, failed, or canceled.
 */
public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable<Channel> {
```

## NioServerSocketChannel

```java
/**
ServerSocketChannel使用基于Nio selector的实现的，用于接收新连接
 * A {@link io.netty.channel.socket.ServerSocketChannel} implementation which uses
 * NIO selector based implementation to accept new connections.
 */
public class NioServerSocketChannel extends AbstractNioMessageChannel
                             implements io.netty.channel.socket.ServerSocketChannel {}
```

## ByteBuf

```java
/**
零个或多个的随机且顺序可访问的字节
 * A random and sequential accessible sequence of zero or more bytes (octets).
 这个接口为一个或多个原始字节数组和ByteBuffer提供了抽象的视图
 * This interface provides an abstract view for one or more primitive byte
 * arrays ({@code byte[]}) and {@linkplain ByteBuffer NIO buffers}.
 *
 * <h3>Creation of a buffer</h3>
 *
 建议创建一个新的buffer使用Unpooled帮助类，不要是用单个实现的构造函数
 * It is recommended to create a new buffer using the helper methods in
 * {@link Unpooled} rather than calling an individual implementation's
 * constructor.
 *
 * <h3>Random Access Indexing</h3>
 *
 就像是普通的原始数组一样，使用
 * Just like an ordinary primitive byte array, {@link ByteBuf} uses
 * <a href="http://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>.
 
 这意味着第一个字节的索引始终为{@code 0}，而最后一个字节的索引始终为{@link #capacity（）capacity-1}。
 * It means the index of the first byte is always {@code 0} and the index of the last byte is
 * always {@link #capacity() capacity - 1}.  For example, to iterate all bytes of a buffer, you
 * can do the following, regardless of its internal implementation:
  * <pre>
 * {@link ByteBuf} buffer = ...;
 * for (int i = 0; i &lt; buffer.capacity(); i ++) {
 *     byte b = buffer.getByte(i);
 *     System.out.println((char) b);
 * }
 * </pre>
 
 顺序访问索引
  * <h3>Sequential Access Indexing</h3>
  
 ByteBuf提供了两个指针变量支持顺序读写操作-readerIndex  writerIndex
 * {@link ByteBuf} provides two pointer variables to support sequential
 * read and write operations - {@link #readerIndex() readerIndex} for a read
 * operation and {@link #writerIndex() writerIndex} for a write operation
 * respectively.
 
 The following diagram shows how a buffer is segmented into
 * three areas by the two pointers:
 *
 * <pre>
 *      +-------------------+------------------+------------------+
 *      | discardable bytes |  readable bytes  |  writable bytes  |
 *      |                   |     (CONTENT)    |                  |
 *      +-------------------+------------------+------------------+
 *      |                   |                  |                  |
 *      0      <=      readerIndex   <=   writerIndex    <=    capacity
 * </pre>
 
 可读字节（实际的类容）
 * <h4>Readable bytes (the actual content)</h4>
 *
 这段是实际存储数据的位置。
 * This segment is where the actual data is stored.  
 
 名称以{@code read}或{@code skip}开头的任何操作都将获取或跳过当前{@link #readerIndex（）readerIndex}处的数据，并增加读取字节数。
 Any operation whose name starts with {@code read} or {@code skip} will get or skip the data at the current {@link #readerIndex() readerIndex} and increase it by the number of read bytes. 
 
 如果读取操作的参数也是bytebuf并且没有指定目标索引，指定buffer的writerIndex是一起增长的
 If the argument of the read operation is also a
 * {@link ByteBuf} and no destination index is specified, the specified
 * buffer's {@link #writerIndex() writerIndex} is increased together.
 * <p>
 如果左边没有充足的内容，indexoutofboundsException会被抛出。
 * If there's not enough content left, {@link IndexOutOfBoundsException} is
 * raised. 
 默认的新分配，包装，拷贝到buffer的readerindex是0
 The default value of newly allocated, wrapped or copied buffer's
 * {@link #readerIndex() readerIndex} is {@code 0}.
 *
 * <pre>
 * // Iterates the readable bytes of a buffer.
 * {@link ByteBuf} buffer = ...;
 * while (buffer.isReadable()) {
 *     System.out.println(buffer.readByte());
 * }
 * </pre>
 *
 * <h4>Writable bytes</h4>
 这段是未定义的空间，是需要被填充的。
 * This segment is a undefined space which needs to be filled.  
 任何以wirte开头的操作将会写数据在当前writerindex位置并且将其增加写入字节数
 Any operation whose name starts with {@code write} will write the data at the current {@link #writerIndex() writerIndex} and increase it by the number of written
 * bytes.
 
 如果写操作的参数是bytebuf,并且没有指定源索引，指定的buffer的readerIndex是一起增加的
 If the argument of the write operation is also a {@link ByteBuf},
 * and no source index is specified, the specified buffer's
 * {@link #readerIndex() readerIndex} is increased together.
 * <p>
 
 如果左边没有充足的写字节空间，IndexOutOfBoundsException抛出
 * If there's not enough writable bytes left, {@link IndexOutOfBoundsException}
 * is raised. 
 
 The default value of newly allocated buffer's
 * {@link #writerIndex() writerIndex} is {@code 0}.  The default value of
 * wrapped or copied buffer's {@link #writerIndex() writerIndex} is the
 * {@link #capacity() capacity} of the buffer.
 *
 
 丢弃的字节
  * <h4>Discardable bytes</h4>
 *
 这段字节内容是已经通过读操作读取过的。
 * This segment contains the bytes which were read already by a read operation.
 
 这段的size是0，但是随着读操作执行，它size大小增加到writerindex。
 * Initially, the size of this segment is {@code 0}, but its size increases up
 * to the {@link #writerIndex() writerIndex} as read operations are executed.
 
 可以通过调用{@link #discardReadBytes（）}回收未使用的区域来丢弃读取的字节，如下图所示
 * The read bytes can be discarded by calling {@link #discardReadBytes()} to
 * reclaim unused area as depicted by the following diagram:
 *
 * <pre>
 *  BEFORE discardReadBytes()
 *
 *      +-------------------+------------------+------------------+
 *      | discardable bytes |  readable bytes  |  writable bytes  |
 *      +-------------------+------------------+------------------+
 *      |                   |                  |                  |
 *      0      <=      readerIndex   <=   writerIndex    <=    capacity
 *
 *
 *  AFTER discardReadBytes()
 *
 *      +------------------+--------------------------------------+
 *      |  readable bytes  |    writable bytes (got more space)   |
 *      +------------------+--------------------------------------+
 *      |                  |                                      |
 * readerIndex (0) <= writerIndex (decreased)        <=        capacity
 * </pre>
 *
 请注意，在调用了discardReadBytes后没有保证可写字节的内容。
 * Please note that there is no guarantee about the content of writable bytes
 * after calling {@link #discardReadBytes()}.  
 
 在多数的情况下，可写字节将不会移动并且根据基础的缓冲区的实现用完全不同的数据填充
 The writable bytes will not be
 * moved in most cases and could even be filled with completely different data
 * depending on the underlying buffer implementation.
 *
 * <h4>Clearing the buffer indexes</h4>
 *
 可以设置readerIndex和writerIndex通过调动clear方法。
 * You can set both {@link #readerIndex() readerIndex} and
 * {@link #writerIndex() writerIndex} to {@code 0} by calling {@link #clear()}.
 这个不会清除内容仅仅清除了两个指针。
 * It does not clear the buffer content (e.g. filling with {@code 0}) but just
 * clears the two pointers. 
 
 另请注意，此操作的语义与{@link ByteBuffer＃clear（）}不同
 Please also note that the semantic of this operation is different from {@link ByteBuffer#clear()}.
 *
 * <pre>
 *  BEFORE clear()
 *
 *      +-------------------+------------------+------------------+
 *      | discardable bytes |  readable bytes  |  writable bytes  |
 *      +-------------------+------------------+------------------+
 *      |                   |                  |                  |
 *      0      <=      readerIndex   <=   writerIndex    <=    capacity
 *
 *
 *  AFTER clear()
 *
 *      +---------------------------------------------------------+
 *      |             writable bytes (got more space)             |
 *      +---------------------------------------------------------+
 *      |                                                         |
 *      0 = readerIndex = writerIndex            <=            capacity
 * </pre>
 *
 
 * <h3>Search operations</h3>
 *
 简单的单字节查找，使用indexOf(int, int, byte)和bytesBefore(int, int, byte)
 * For simple single-byte searches, use {@link #indexOf(int, int, byte)} and {@link #bytesBefore(int, int, byte)}.
 
 bytesBefore(int, int, byte)是特别有用，当你处理已经结束的字符串。
 * {@link #bytesBefore(byte)} is especially useful when you deal with a {@code NUL}-terminated string.
 
 对于复杂的查找，使用#forEachByte(int, int, ByteProcessor)，使用一个ByteProcessor实现类
 * For complicated searches, use {@link #forEachByte(int, int, ByteProcessor)} with a {@link ByteProcessor}
 * implementation.
 *
 * <h3>Mark and reset</h3>
 *
 在每一个buffer中都有连个标记下标。一个是存储readerindex并且另一个是存储writerIndex
 * There are two marker indexes in every buffer. One is for storing
 * {@link #readerIndex() readerIndex} and the other is for storing
 * {@link #writerIndex() writerIndex}.  
 
 能够总是调用reset方法复位两个下标之一。
 You can always reposition one of the two indexes by calling a reset method.  
 
 它的工作方式与{@link InputStream}中的mark和reset方法类似，但是没有readlimit
 It works in a similar fashion to the mark and reset methods in {@link InputStream} except that there's no
 * {@code readlimit}.
 *
 
 * <h3>Conversion to existing JDK types</h3>
 *
 * <h4>Byte array</h4>
 *
 如果一个bytebuf是由byte array支持，你能够通过array()方法直接访问它。
 * If a {@link ByteBuf} is backed by a byte array (i.e. {@code byte[]}),
 * you can access it directly via the {@link #array()} method. 
 
 确定一个buffer是否有一个byte array支持，应该使用hasArray()
 To determine if a buffer is backed by a byte array, {@link #hasArray()} should be used.
 *
 * <h4>NIO Buffers</h4>
 *
 如果{@link ByteBuf}可以转换为共享其内容（即视图缓冲区）的NIO {@link ByteBuffer}，则可以通过{@link #nioBuffer（）}方法获取它
 * If a {@link ByteBuf} can be converted into an NIO {@link ByteBuffer} which shares its content (i.e. view buffer), you can get it via the {@link #nioBuffer()} method.
 
确定一个buffer是否能够转化为一个NIO buffer，使用nioBufferCount
 To determine if a buffer can be converted into an NIO buffer, use {@link #nioBufferCount()}.
 *
 * <h4>Strings</h4>
 *
 * Various {@link #toString(Charset)} methods convert a {@link ByteBuf}
 * into a {@link String}.  Please note that {@link #toString()} is not a
 * conversion method.
 *
 * <h4>I/O Streams</h4>
 *
 * Please refer to {@link ByteBufInputStream} and
 * {@link ByteBufOutputStream}.
 */
public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
    
}
```

## ReferenceCounted引用计数

```java
/**
需要显式释放的引用计数对象
 * A reference-counted object that requires explicit deallocation.
 * <p>
 
 当一个新的引用计数被实例化，开始引用计数为1
 * When a new {@link ReferenceCounted} is instantiated, it starts with the reference count of {@code 1}.
 
 retain方法增长引用计数，并且通过release()减少reference count
 * {@link #retain()} increases the reference count, and {@link #release()} decreases the reference count.
 
 如果一个引用计数被减到0，该对象将被显式释放，访问该释放对象通常会导致访问冲突
 * If the reference count is decreased to {@code 0}, the object will be deallocated explicitly, and accessing the deallocated object will usually result in an access violation.
 * </p>
 * <p>
 
 
 * If an object that implements {@link ReferenceCounted} is a container of other objects that implement
 * {@link ReferenceCounted}, the contained objects will also be released via {@link #release()} when the container's
 * reference count becomes 0.
 * </p>
 */
public interface ReferenceCounted {}
```

## ByteBufAllocator

```java
/**
实现负责分配缓冲区。 预计该接口的实现线程安全的
 * Implementations are responsible to allocate buffers. Implementations of this interface are expected to be thread-safe.
 */
public interface ByteBufAllocator {
    
  /**
     * Create a heap {@link ByteBuf} with the given initialCapacity and maxCapacity.
     */
    protected abstract ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity);

    /**
     * Create a direct {@link ByteBuf} with the given initialCapacity and maxCapacity.
     */
    protected abstract ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity);
}

```

```java
public class PooledByteBufAllocator extends AbstractByteBufAllocator implements ByteBufAllocatorMetricProvider {
    
    final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {
        private final boolean useCacheForAllThreads;

        PoolThreadLocalCache(boolean useCacheForAllThreads) {
            this.useCacheForAllThreads = useCacheForAllThreads;
        }

        @Override
        protected synchronized PoolThreadCache initialValue() {
            final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas);
            final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);

            final Thread current = Thread.currentThread();
            if (useCacheForAllThreads || current instanceof FastThreadLocalThread) {
                final PoolThreadCache cache = new PoolThreadCache(
                        heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,
                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);

                if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {
                    final EventExecutor executor = ThreadExecutorMap.currentExecutor();
                    if (executor != null) {
                        executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,
                                DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);
                    }
                }
                return cache;
            }
            // No caching so just use 0 as sizes.
            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);
        }
    
	@Override
    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {
        
        //这里通过ThreadLocal实现获取的
        PoolThreadCache cache = threadCache.get();
        PoolArena<ByteBuffer> directArena = cache.directArena;

        final ByteBuf buf;
        if (directArena != null) {
            buf = directArena.allocate(cache, initialCapacity, maxCapacity);
        } else {
            buf = PlatformDependent.hasUnsafe() ?
                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :
                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);
        }

        return toLeakAwareBuffer(buf);
    }
}

/**
 ThreadLocal的特殊的变体，当从FastThreadLocalThread访问时，具有更高的访问性能
 * A special variant of {@link ThreadLocal} that yields higher access performance when accessed from a
 * {@link FastThreadLocalThread}.
 * <p>
 
 内部，一个FastThreadLocal在数组中使用一个常量索引，替换hash code和hash table,去查找变量。
* Internally, a {@link FastThreadLocal} uses a constant index in an array, instead of using hash code and hash table, to look for a variable. 

Although seemingly very subtle, it yields slight performance advantage over using a hash
 * table, and it is useful when accessed frequently.
 */
public class FastThreadLocal<V> {
    public final V get() {
        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();
        Object v = threadLocalMap.indexedVariable(index);
        if (v != InternalThreadLocalMap.UNSET) {
            return (V) v;
        }

        return initialize(threadLocalMap);
    }
    
    private V initialize(InternalThreadLocalMap threadLocalMap) {
        V v = null;
        try {
            v = initialValue();
        } catch (Exception e) {
            PlatformDependent.throwException(e);
        }

        threadLocalMap.setIndexedVariable(index, v);
        addToVariablesToRemove(threadLocalMap, this);
        return v;
    }
}
```

## ByteBufUtil

```java
/**
 * A collection of utility methods that is related with handling {@link ByteBuf},
 * such as the generation of hex dump and swapping an integer's byte order.
 */
public final class ByteBufUtil {
static {
        String allocType = SystemPropertyUtil.get(
                "io.netty.allocator.type", PlatformDependent.isAndroid() ? "unpooled" : "pooled");
        allocType = allocType.toLowerCase(Locale.US).trim();

        ByteBufAllocator alloc;
        if ("unpooled".equals(allocType)) {
            alloc = UnpooledByteBufAllocator.DEFAULT;
            logger.debug("-Dio.netty.allocator.type: {}", allocType);
        } else if ("pooled".equals(allocType)) {
            alloc = PooledByteBufAllocator.DEFAULT;
            logger.debug("-Dio.netty.allocator.type: {}", allocType);
        } else {
            alloc = PooledByteBufAllocator.DEFAULT;
            logger.debug("-Dio.netty.allocator.type: pooled (unknown: {})", allocType);
        }

        DEFAULT_ALLOCATOR = alloc;

        THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 0);
        logger.debug("-Dio.netty.threadLocalDirectBufferSize: {}", THREAD_LOCAL_BUFFER_SIZE);

        MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.maxThreadLocalCharBufferSize", 16 * 1024);
        logger.debug("-Dio.netty.maxThreadLocalCharBufferSize: {}", MAX_CHAR_BUFFER_SIZE);
    }
    }
```

## PooledByteBufAllocator

```java
public class PooledByteBufAllocator extends AbstractByteBufAllocator implements ByteBufAllocatorMetricProvider {

    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PooledByteBufAllocator.class);
    private static final int DEFAULT_NUM_HEAP_ARENA;
    private static final int DEFAULT_NUM_DIRECT_ARENA;

    private static final int DEFAULT_PAGE_SIZE;
    private static final int DEFAULT_MAX_ORDER; // 8192 << 11 = 16 MiB per chunk
    private static final int DEFAULT_TINY_CACHE_SIZE;
    private static final int DEFAULT_SMALL_CACHE_SIZE;
    private static final int DEFAULT_NORMAL_CACHE_SIZE;
    private static final int DEFAULT_MAX_CACHED_BUFFER_CAPACITY;
    private static final int DEFAULT_CACHE_TRIM_INTERVAL;
    private static final long DEFAULT_CACHE_TRIM_INTERVAL_MILLIS;
    private static final boolean DEFAULT_USE_CACHE_FOR_ALL_THREADS;
    private static final int DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT;
    static final int DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK;
    
     private static final int MIN_PAGE_SIZE = 4096;
    private static final int MAX_CHUNK_SIZE = (int) (((long) Integer.MAX_VALUE + 1) / 2);

    private final Runnable trimTask = new Runnable() {
        @Override
        public void run() {
            PooledByteBufAllocator.this.trimCurrentThreadCache();
        }
    };

    static {
        int defaultPageSize = SystemPropertyUtil.getInt("io.netty.allocator.pageSize", 8192);
        Throwable pageSizeFallbackCause = null;
        try {
            validateAndCalculatePageShifts(defaultPageSize);
        } catch (Throwable t) {
            pageSizeFallbackCause = t;
            defaultPageSize = 8192;
        }
        DEFAULT_PAGE_SIZE = defaultPageSize;

        int defaultMaxOrder = SystemPropertyUtil.getInt("io.netty.allocator.maxOrder", 11);
        Throwable maxOrderFallbackCause = null;
        try {
            validateAndCalculateChunkSize(DEFAULT_PAGE_SIZE, defaultMaxOrder);
        } catch (Throwable t) {
            maxOrderFallbackCause = t;
            defaultMaxOrder = 11;
        }
        
        DEFAULT_MAX_ORDER = defaultMaxOrder;//11

        //为nHeapArena和nDirectArena确定合理的默认值。
        // Determine reasonable default for nHeapArena and nDirectArena.
        
        //假设每个竞技场有3个块，则该池消耗的内存不应超过最大内存的50％。
        // Assuming each arena has 3 chunks, the pool should not consume more than 50% of max memory.
        final Runtime runtime = Runtime.getRuntime();

        /*
        默认情况下，我们使用2 *可用处理器来减少争用，因为我们也将2 *可用处理器用于NIO和EPOLL中的EventLoop。
         * We use 2 * available processors by default to reduce contention as we use 2 * available processors for the
         * number of EventLoops in NIO and EPOLL as well. If we choose a smaller number we will run into hot spots as
         * allocation and de-allocation needs to be synchronized on the PoolArena.
         *
         * See https://github.com/netty/netty/issues/3888.
         */
        
        //这里获取到可用cpu核心数，最为默认最小的Arena数量
        final int defaultMinNumArena = NettyRuntime.availableProcessors() * 2;
        //默认是pagesize左移11位，作为chunksize的大小
        final int defaultChunkSize = DEFAULT_PAGE_SIZE << DEFAULT_MAX_ORDER;
        DEFAULT_NUM_HEAP_ARENA = Math.max(0,
                SystemPropertyUtil.getInt(
                        "io.netty.allocator.numHeapArenas",
                        (int) Math.min(
                                defaultMinNumArena,
                                runtime.maxMemory() / defaultChunkSize / 2 / 3)));
        DEFAULT_NUM_DIRECT_ARENA = Math.max(0,
                SystemPropertyUtil.getInt(
                        "io.netty.allocator.numDirectArenas",
                        (int) Math.min(
                                defaultMinNumArena,
                                PlatformDependent.maxDirectMemory() / defaultChunkSize / 2 / 3)));

        // cache sizes
        DEFAULT_TINY_CACHE_SIZE = SystemPropertyUtil.getInt("io.netty.allocator.tinyCacheSize", 512);
        DEFAULT_SMALL_CACHE_SIZE = SystemPropertyUtil.getInt("io.netty.allocator.smallCacheSize", 256);
        DEFAULT_NORMAL_CACHE_SIZE = SystemPropertyUtil.getInt("io.netty.allocator.normalCacheSize", 64);

        // 32 kb is the default maximum capacity of the cached buffer. Similar to what is explained in
        // 'Scalable memory allocation using jemalloc'
        DEFAULT_MAX_CACHED_BUFFER_CAPACITY = SystemPropertyUtil.getInt(
                "io.netty.allocator.maxCachedBufferCapacity", 32 * 1024);

        // the number of threshold of allocations when cached entries will be freed up if not frequently used
        DEFAULT_CACHE_TRIM_INTERVAL = SystemPropertyUtil.getInt(
                "io.netty.allocator.cacheTrimInterval", 8192);

        DEFAULT_CACHE_TRIM_INTERVAL_MILLIS = SystemPropertyUtil.getLong(
                "io.netty.allocation.cacheTrimIntervalMillis", 0);

        DEFAULT_USE_CACHE_FOR_ALL_THREADS = SystemPropertyUtil.getBoolean(
                "io.netty.allocator.useCacheForAllThreads", true);

        DEFAULT_DIRECT_MEMORY_CACHE_ALIGNMENT = SystemPropertyUtil.getInt(
                "io.netty.allocator.directMemoryCacheAlignment", 0);

        // Use 1023 by default as we use an ArrayDeque as backing storage which will then allocate an internal array
        // of 1024 elements. Otherwise we would allocate 2048 and only use 1024 which is wasteful.
        DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK = SystemPropertyUtil.getInt(
                "io.netty.allocator.maxCachedByteBuffersPerChunk", 1023);

        if (logger.isDebugEnabled()) {
            logger.debug("-Dio.netty.allocator.numHeapArenas: {}", DEFAULT_NUM_HEAP_ARENA);
            logger.debug("-Dio.netty.allocator.numDirectArenas: {}", DEFAULT_NUM_DIRECT_ARENA);
            if (pageSizeFallbackCause == null) {
                logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE);
            } else {
                logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE, pageSizeFallbackCause);
            }
            if (maxOrderFallbackCause == null) {
                logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER);
            } else {
                logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER, maxOrderFallbackCause);
            }
            logger.debug("-Dio.netty.allocator.chunkSize: {}", DEFAULT_PAGE_SIZE << DEFAULT_MAX_ORDER);
            logger.debug("-Dio.netty.allocator.tinyCacheSize: {}", DEFAULT_TINY_CACHE_SIZE);
            logger.debug("-Dio.netty.allocator.smallCacheSize: {}", DEFAULT_SMALL_CACHE_SIZE);
            logger.debug("-Dio.netty.allocator.normalCacheSize: {}", DEFAULT_NORMAL_CACHE_SIZE);
            logger.debug("-Dio.netty.allocator.maxCachedBufferCapacity: {}", DEFAULT_MAX_CACHED_BUFFER_CAPACITY);
            logger.debug("-Dio.netty.allocator.cacheTrimInterval: {}", DEFAULT_CACHE_TRIM_INTERVAL);
            logger.debug("-Dio.netty.allocator.cacheTrimIntervalMillis: {}", DEFAULT_CACHE_TRIM_INTERVAL_MILLIS);
            logger.debug("-Dio.netty.allocator.useCacheForAllThreads: {}", DEFAULT_USE_CACHE_FOR_ALL_THREADS);
            logger.debug("-Dio.netty.allocator.maxCachedByteBuffersPerChunk: {}",
                    DEFAULT_MAX_CACHED_BYTEBUFFERS_PER_CHUNK);
        }
    }
}
```

### 分配ByteBuf流程

```java
public class MyTest {
    public static void main(String[] args) {
        //true申请分配堆外内存
        PooledByteBufAllocator allocator = new PooledByteBufAllocator(true);
        ByteBuf buffer = allocator.buffer(112);
    }
}

//AbstractByteBufAllocator
@Override
    public ByteBuf buffer(int initialCapacity) {
        if (directByDefault) {
            //进入该方法
            return directBuffer(initialCapacity);
        }
        return heapBuffer(initialCapacity);
    }

 @Override
    public ByteBuf directBuffer(int initialCapacity) {
        return directBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);
    }

@Override
    public ByteBuf directBuffer(int initialCapacity, int maxCapacity) {
        if (initialCapacity == 0 && maxCapacity == 0) {
            return emptyBuf;
        }
        validate(initialCapacity, maxCapacity);
        return newDirectBuffer(initialCapacity, maxCapacity);
    }

//PooledByteBufAllocator
@Override
    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {
        
        //使用jemalloc进行可伸缩的内存分配,充当分配的线程缓存
        PoolThreadCache cache = threadCache.get();
        PoolArena<ByteBuffer> directArena = cache.directArena;

        final ByteBuf buf;
        if (directArena != null) {
            //PoolArena分配内存，返回ByteBuf
            buf = directArena.allocate(cache, initialCapacity, maxCapacity);
        } else {
            buf = PlatformDependent.hasUnsafe() ?
                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :
                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);
        }

        return toLeakAwareBuffer(buf);
    }

//PoolArena
PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {
        PooledByteBuf<T> buf = newByteBuf(maxCapacity);
        allocate(cache, buf, reqCapacity);
        return buf;
    }
 @Override
        protected PooledByteBuf<ByteBuffer> newByteBuf(int maxCapacity) {
            //判断有没有unsafe这个类
            if (HAS_UNSAFE) {
                return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);
            } else {
                return PooledDirectByteBuf.newInstance(maxCapacity);
            }
        }

//Recycler
/**
基于thread local栈的轻量级对象池
 * Light-weight object pool based on a thread-local stack.
 *
 * @param <T> the type of the pooled object
 */
public abstract class Recycler<T> {//回收站
    
    public final T get() {
        if (maxCapacityPerThread == 0) {
            return newObject((Handle<T>) NOOP_HANDLE);
        }
        //从FastThreadLocal中获取InternalThreadLocalMap
        Stack<T> stack = threadLocal.get();
        DefaultHandle<T> handle = stack.pop();
        if (handle == null) {
            handle = stack.newHandle();
            handle.value = newObject(handle);
        }
        return (T) handle.value;
    }
}

//FastThreadLocal
public final V get() {
        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();
        Object v = threadLocalMap.indexedVariable(index);
        if (v != InternalThreadLocalMap.UNSET) {
            return (V) v;
        }
		//没有获取到stack进入进行初始化
        return initialize(threadLocalMap);
    }

private V initialize(InternalThreadLocalMap threadLocalMap) {
        V v = null;
        try {
            //进入该方法，获得stack
            v = initialValue();
            
 /*
 private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {
        @Override
        protected Stack<T> initialValue() {
            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,
                    interval, maxDelayedQueuesPerThread);
        }

        @Override
        protected void onRemoval(Stack<T> value) {
            // Let us remove the WeakOrderQueue from the WeakHashMap directly if its safe to remove some overhead
            if (value.threadRef.get() == Thread.currentThread()) {
               if (DELAYED_RECYCLED.isSet()) {
                   DELAYED_RECYCLED.get().remove(value);
               }
            }
        }
    };*/
        } catch (Exception e) {
            PlatformDependent.throwException(e);
        }
		//将这个stack保存到threadlocalMap中，
        threadLocalMap.setIndexedVariable(index, v);
        addToVariablesToRemove(threadLocalMap, this);
        return v;
    }
```

## 启动流程

```java
//创建一个程序启动器，这里用的门面模式
ServerBootstrap b = new ServerBootstrap();
//将主线程和worker线程添加里面group，childGroup
b.group(bossGroup, workerGroup)
    //创建了一个该类channelFactory,将该factory添加到内部
 .channel(NioServerSocketChannel.class)
  //这里涉及到TCP建立连接时的两个队列，半连接队列，全连接队列，100指两个队列的容量和，如果满了有连接来就执行对应的0，1策略，丢弃或者连接重置
 .option(ChannelOption.SO_BACKLOG, 100)
  //添加ChannelHandler逻辑，未应用在主线程上
 .handler(new LoggingHandler(LogLevel.INFO))
  //添加worker线程的逻辑，未应用到worker线程上
 .childHandler(new ChannelInitializer<SocketChannel>() {
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline p = ch.pipeline();
         if (sslCtx != null) {
             p.addLast(sslCtx.newHandler(ch.alloc()));
         }
         //p.addLast(new LoggingHandler(LogLevel.INFO));
         p.addLast(serverHandler);
     }
 });

 // Start the server.
//bind见下面AbstractBootstrap部分代码
            ChannelFuture f = b.bind(PORT).sync();

            // Wait until the server socket is closed.
            f.channel().closeFuture().sync();
```

```java
//AbstractBootstrap

public ChannelFuture bind(int inetPort) {
        return bind(new InetSocketAddress(inetPort));
    }


    public ChannelFuture bind(SocketAddress localAddress) {
        //里面验证主线程==null,bossgroup为null就会抛异常，验证childgroup是不是为null,如果childGroup为null，则会共用bossgroup
        validate();
        return doBind(ObjectUtil.checkNotNull(localAddress, "localAddress"));
    }


    private ChannelFuture doBind(final SocketAddress localAddress) {
        //1、通过添加的channelFactory创建了NioServerSocketChannel
        //2、初始化NioServerSocketChannel
        	//2.1、设置了ChannelOptions
        	//2.2、设置属性（属性为空）
        	//2.3、
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
            return regFuture;
        }

        if (regFuture.isDone()) {
            // At this point we know that the registration was complete and successful.
            ChannelPromise promise = channel.newPromise();
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            // Registration future is almost always fulfilled already, but just in case it's not.
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                        // IllegalStateException once we try to access the EventLoop of the Channel.
                        promise.setFailure(cause);
                    } else {
                        // Registration was successful, so set the correct executor to use.
                        // See https://github.com/netty/netty/issues/2586
                        promise.registered();

                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
```
# KMP算法

KMP是一种字符串匹配算法，其核心就是利用匹配失败后的信息，尽量减少无用的匹配次数达到快速匹配的目的。

## 暴力匹配

用这种方式的时间复杂度为O(M*N);

在字符串s中**a b c a b c a b d a b b a **中是否包含字符串**a b c a b d **

第一次匹配，指针m在下标5的位置匹配失败，指针m需要回退到0位置，

第二次匹配，从字符串s下标1的位置开始匹配

![](.\images\图1.png)

这种暴力匹配的方式效率太低，不管前期子串匹配的多么成功，到最后只要有一个不同，那么就需要将前面匹配过的字符再匹配一遍。

## 通过子串生成加速数组

通过遍历子串，生成一个对应相同长度的数组，该数组的本质：遍历子串的每个字符，计算该字符之前的字符串前缀等于后缀的最大长度（不包含整个字符串）；

比如字符串**ABABABD**生成的数组为[-1,0,0,1,2,3,4];

1. 第一个字符默认生成的就是-1；

2. 第二个字符"B"，之前的字符串就只有"A"，求A前缀等于后缀的最大长度，但不能是整个字符串所以结果就是0；

   ![](.\images\图2.png)

3. 来到第三个字符，之前是"AB"字符串，结果为0；

   ![](.\images\图3.png)

4. 第四个字符，之前是"ABA"字符串，前缀A等于后缀A，结果为1；

   ![](.\images\图4.png)

5. 第五个字符，之前是"ABAB"字符串，前缀AB等于后缀AB,结果为2；

   ![](.\images\图5.png)

6. 第六个字符，之前是"ABABA"字符串，前缀ABA等于后缀ABA,结果为3；

   ![](.\images\图6.png)

7. 来到最后一个字符，之前是"ABABAB"字符串，前缀ABAB等于后缀ABAB,结果为4；

   ![](.\images\图7.png)

## KMP的两个加速

## 第一个加速

1. 如图，当**I**和**J**不匹配的时候，通过加速数组可以得到 **J** 字符之前前缀和后缀相同的长度，所以蓝色1、2部分是相等的；又因为主串**I**字符之前有一段肯定和子串**J**之前的字符串完全相等，所以蓝色1、3部分是相等；

   ![](.\images\图8.png)

2. 只需要移动子指针到蓝色1的下一个字符，主指针不动，进行匹配，这样省去了蓝色1、3部分的对比；

   ![](.\images\图9.png)

## 第二个加速

- 主指针是不需要向前移动，以蓝色3之前的字符开头的字符串是不会出现和子串完全匹配的字符串的；

- 如图，假设**I**之前有个以**Y**开头字符能够和子串完全匹配，那么**Y到I这部分串1**肯定和**串2**是相等的，又因为主串和子串是匹配到**I和J**不等，所以串1和串3部分肯定也是相等的；也就得出  **串2和串3**是完全相等的，但是之前已经通过计算得到子串的加速数组，**J**之前前缀和后缀最长就是蓝色部分，现在又出现了一个更长的，所以假设不成立的；

  ![](.\images\图10.png)


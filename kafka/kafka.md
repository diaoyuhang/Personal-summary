# KAFKA

## 保证消息发送的有序性，消费的有序性，持久化更新offset

一旦消息的类型多了，且需要保证同类型消息的有序性，消息是K,V键值对，相同的key一定会到一个分区中，broker会保证producer发送消息的顺序；

一个分区可能有不同的key，且不同的key交叉，consumer消费的时候分两种情况：

1. 消息队列主动推送，再数据量不大的时候能够保证实时性，但是如果consumer的接受队列满了，同样会造成延时；
2. consumer主动拉取数据
   1. 一条一条的拉去，很浪费性能
   2. 按批次拉取，处理的时候，可以单线程处理，也可以多线程处理
      - 单线程处理的时候，就一条按照顺序处理，更新offset，实现方便简单，速度较慢；
      - 多线程处理的时候，需要将一个批次中的数据按照key进行发送到不同线程的队列中，保证相同类型的消息的有序性，多线程处理消息，单线程一个事务中更新这一个批次的offset，保证这个批次的数据要么成功，要么失败，这样也减少了对DB的压力，和offset的频率的压力，更多利用cpu等硬件资源；


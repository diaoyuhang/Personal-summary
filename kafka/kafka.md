# KAFKA

## 保证消息发送的有序性，消费的有序性，持久化更新offset

一旦消息的类型多了，且需要保证同类型消息的有序性，消息是K,V键值对，相同的key一定会到一个分区中，broker会保证producer发送消息的顺序；

一个分区可能有不同的key，且不同的key交叉，consumer消费的时候分两种情况：

1. 消息队列主动推送，再数据量不大的时候能够保证实时性，但是如果consumer的接受队列满了，同样会造成延时；
2. consumer主动拉取数据
   1. 一条一条的拉去，很浪费性能
   2. 按批次拉取，处理的时候，可以单线程处理，也可以多线程处理
      - 单线程处理的时候，就一条按照顺序处理，更新offset，实现方便简单，速度较慢；
      - 多线程处理的时候，需要将一个批次中的数据按照key进行发送到不同线程的队列中，保证相同类型的消息的有序性，多线程处理消息，单线程一个事务中更新这一个批次的offset，保证这个批次的数据要么成功，要么失败，这样也减少了对DB的压力，和offset的频率的压力，更多利用cpu等硬件资源；

## kafka消息数据的同步

ISR:所有与leader副本保持一定程度的同步副本，组成ISR

OSR:与leader副本同步滞后的副本，或没有心跳的，组成OSR

AR:分区的所有副本统称为AR

设置ack=0的时候，生产者只会发送数据，不会在意leader有没有收到

ack=1，kafka保证了leader一定能够持久化消息，但是其他副本不管

ack=-1，保证同处于ISR状态中的副本都同步leader的消息